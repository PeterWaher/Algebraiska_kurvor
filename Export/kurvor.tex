%% Created by Maple 2015.1, Windows 8
%% Source Worksheet: kurvor.mw
%% Generated: Fri Oct 02 18:51:07 CEST 2015
\documentclass{article}
\usepackage{maplestd2e}
\def\emptyline{\vspace{12pt}}
\begin{document}
\pagestyle{empty}
\DefineParaStyle{Maple Heading 1}
\DefineParaStyle{Maple Text Output}
\DefineParaStyle{Maple Dash Item}
\DefineParaStyle{Maple Bullet Item}
\DefineParaStyle{Maple Normal}
\DefineParaStyle{Maple Heading 4}
\DefineParaStyle{Maple Heading 3}
\DefineParaStyle{Maple Heading 2}
\DefineParaStyle{Maple Warning}
\DefineParaStyle{Maple Title}
\DefineParaStyle{Maple Error}
\DefineCharStyle{Maple Hyperlink}
\DefineCharStyle{Maple 2D Math}
\DefineCharStyle{Maple Maple Input}
\DefineCharStyle{Maple 2D Output}
\DefineCharStyle{Maple 2D Input}
\begin{Maple Heading 1}{
\begin{Maple Heading 1}{
\textbf{MakePoly}\mapleinline{inert}{2d}{}{$\displaystyle $}
}\end{Maple Heading 1}

}\end{Maple Heading 1}

\begin{maplelatex}\begin{center}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (a, Variable) local i, r; r := 0; for i to nops(a) do if op(i, a) <> 0 then r := r+op(i, a)*Variable^(i-1) end if end do; RETURN(sort(r)) end proc}{\[\displaystyle \textbf{proc} (aVariable) \\
\textbf{local} \,i,\,r; \\
\mapleIndent{1} r\,:=\,0;\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,\mathit{nops} (a) \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,\mathit{op} (i,\,a) \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} r\,:=\,r + \mathit{op} (i,\,a) \ast Variable\hat{~}{i + -1}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{sort} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\end{center}
\end{maplelatex}
\begin{Maple Normal}{
\begin{Maple Normal}{
}\end{Maple Normal}
}\end{Maple Normal}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{MakePoly([1, 2, 3, 4, 5], x)}{\[{\it MakePoly} \left( [1,2,3,4,5],x \right) \]}
\end{mapleinput}
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{5*x^4+4*x^3+3*x^2+2*x+1}{\[\displaystyle 5\,{x}^{4}+4\,{x}^{3}+3\,{x}^{2}+2\,x+1\]}
\end{maplelatex}
\end{maplegroup}
\begin{Maple Heading 1}{
\begin{Maple Heading 1}{
\textbf{Composition}}\end{Maple Heading 1}

}\end{Maple Heading 1}

\begin{maplelatex}\begin{center}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (f, g, Variable, MaxDegree) local gc, gcn, gcnt, i, j, k, r, c, floop; gc := array(0 .. MaxDegree); gcn := array(0 .. MaxDegree); gcnt := array(0 .. MaxDegree); r := array(0 .. MaxDegree); for i from 0 to MaxDegree do gc[i] := coeff(g, Variable, i); gcn[i] := gc[i]; r[i] := 0 end do; floop := degree(f); if MaxDegree < floop then floop := MaxDegree end if; r[0] := coeff(f, Variable, 0); for i to floop do c := coeff(f, Variable, i); for j from 0 to MaxDegree do r[j] := r[j]+c*gcn[j] end do; if i < MaxDegree then for j from 0 to MaxDegree do gcnt[j] := 0; for k from 0 to j do gcnt[j] := gc[k]*gcn[j-k]+gcnt[j] end do end do; for j from 0 to MaxDegree do gcn[j] := gcnt[j] end do end if end do; RETURN(eval(r)) end proc}{\[\displaystyle \textbf{proc} (fgVariableMaxDegree) \\
\textbf{local} \,gc,\,gcn,\,gcnt,\,i,\,j,\,k,\,r,\,c,\,floop; \\
\mapleIndent{1} gc\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcn\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} gcnt\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} r\,:=\,\mathit{array} (0..MaxDegree);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} gc[i]\,:=\,\mathit{coeff} (g,\,Variable,\,i);\\
\mapleIndent{2} gcn[i]\,:=\,gc[i];\\
\mapleIndent{2} r[i]\,:=\,0\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} floop\,:=\,\mathit{degree} (f);\\
\mapleIndent{1} \textbf{if} \,MaxDegree<floop \, \textbf{then} \\
\mapleIndent{2} floop\,:=\,MaxDegree\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} r[0]\,:=\,\mathit{coeff} (f,\,Variable,\,0);\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,floop \,\textbf{do}\\
\mapleIndent{2} c\,:=\,\mathit{coeff} (f,\,Variable,\,i);\\
\mapleIndent{2} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{3} r[j]\,:=\,r[j] + c \ast gcn[j]\\
\mapleIndent{2} \textbf{end\ do};;\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcnt[j]\,:=\,0;\\
\mapleIndent{4} \textbf{for} \,k \,\textbf{from} \,0 \,\textbf{to} \,j \,\textbf{do}\\
\mapleIndent{5} gcnt[j]\,:=\,gc[k] \ast gcn[j-k] + gcnt[j]\\
\mapleIndent{4} \textbf{end\ do};\\
\mapleIndent{3} \textbf{end\ do};;\\
\mapleIndent{3} \textbf{for} \,j \,\textbf{from} \,0 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} gcn[j]\,:=\,gcnt[j]\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \mathit{RETURN} (\mathit{eval} (r))\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\end{center}
\end{maplelatex}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Composition(x^2+1, x^3+x^2+1, x, 6)}{\[{\it Composition} \left( {x}^{2}+1,{x}^{3}+{x}^{2}+1,x,6 \right) \]}
\end{mapleinput}
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{ARRAY([0 .. 6], [0 = 2, 1 = 0, 2 = 2, 3 = 2, 4 = 1, 5 = 2, 6 = 1])}{\[\displaystyle {\it ARRAY} \left( [{0\ldots 6}],[0=2,1=0,2=2,3=2,4=1,5\\
\mbox{}=2,6=1] \right) \]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{expand(subs(x = x^3+x^2+1, x^2+1))}{\[{\it expand} \left( {\it subs} \left( x={x}^{3}+{x}^{2}+1,{x}^{2}+1 \right)  \right) \]}
\end{mapleinput}
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{x^6+2*x^5+x^4+2*x^3+2*x^2+2}{\[\displaystyle {x}^{6}+2\,{x}^{5}+{x}^{4}+2\,{x}^{3}+2\,{x}^{2}+2\]}
\end{maplelatex}
\end{maplegroup}
\begin{Maple Heading 1}{
\begin{Maple Heading 1}{
\textbf{Reparametrize}}\end{Maple Heading 1}

}\end{Maple Heading 1}

\begin{Maple Normal}{
\begin{Maple Normal}{
\mapleinline{inert}{2d}{}{\[\displaystyle \]}
}\end{Maple Normal}
}\end{Maple Normal}
\begin{maplelatex}\begin{center}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\begin{maplelatex}\begin{center}
\mapleinline{inert}{2d}{proc (x, y, Variable, t0, MaxDegree, Branch, AllowNegation) local xt, yt, a, p, q, x0, y0, i, j, k, shifted, temp, sols, StartTime, MinDegree, arg, z, Negate; StartTime := time(); if not type(Branch, integer) then ERROR("Branch must be an integer!", Branch) end if; if t0 <> 0 then xt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, x)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(collect(expand(subs(Variable = Variable+t0, y)), Variable), Variable = 0, MaxDegree+1), polynom)), Variable) else xt := collect(expand(convert(taylor(x, Variable = 0, MaxDegree+1), polynom)), Variable); yt := collect(expand(convert(taylor(y, Variable = 0, MaxDegree+1), polynom)), Variable) end if; x0 := coeff(xt, Variable, 0); y0 := coeff(yt, Variable, 0); xt := xt-x0; yt := yt-y0; MinDegree := ldegree(xt, Variable); shifted := ldegree(yt, Variable) < MinDegree; if shifted then temp := xt; xt := yt; yt := temp; MinDegree := ldegree(xt, Variable) end if; a := array(1 .. MaxDegree-MinDegree+1); z := 1/coeff(xt, Variable, MinDegree); if z < 0 and AllowNegation then xt := -xt; z := -z; Negate := true else Negate := false end if; arg := argument(z); a[1] := abs(z)^(1/MinDegree)*(cos(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)+I*sin(((2*MinDegree-4+2*Branch)*Pi+arg)/MinDegree)); p := a[1]*Variable; for j from 2 to MaxDegree-MinDegree+1 do p := p+a[j]*Variable^j end do; q := Composition(yt, p, Variable, MaxDegree); p := Composition(xt, p, Variable, MaxDegree); i := MinDegree+1; j := 2; while i <= MaxDegree do sols := [solve(p[i] = 0, a[j])]; q[i] := expand(subs(a[j] = sols[1], q[i])); if i < MaxDegree then for k from i+1 to MaxDegree do p[k] := subs(a[j] = sols[1], p[k]); q[k] := subs(a[j] = sols[1], q[k]) end do end if; a[j] := sols[1]; i := i+1; j := j+1 end do; xt := q[0]; for i to MaxDegree do if q[i] <> 0 then xt := xt+q[i]*Variable^i end if end do; if shifted then xt := x0+xt; if Negate then yt := y0-Variable^MinDegree else yt := y0+Variable^MinDegree end if else yt := y0+xt; if Negate then xt := x0-Variable^MinDegree else xt := x0+Variable^MinDegree end if end if; printf("Elapsed Time: %0.3f s.\n", time()-StartTime); RETURN([xt, yt]) end proc}{\[\displaystyle \textbf{proc} (xyVariablet0MaxDegreeBranchAllowNegation) \\
\textbf{local} \,xt,\,yt,\,a,\,p,\,q,\,x0,\,y0,\,i,\,j,\,k,\,shifted,\,temp,\,sols,\,StartTime,\,MinDegree,\,arg,\,z,\,Negate; \\
\mapleIndent{1} StartTime\,:=\,\mathit{time} ();\\
\mapleIndent{1} \textbf{if} \,\textbf{not} \,\mathit{type} (Branch,\,integer) \, \textbf{then} \\
\mapleIndent{2} \mathit{ERROR} (``Branch\ must\ be\ an\ integer!'',\,Branch)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \textbf{if} \,t0 \, <> \, 0 \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,x)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (\mathit{collect} (\mathit{expand} (\mathit{subs} (Variable \, = \, Variable + t0,\,y)),\,Variable),\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} xt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (x,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable);\\
\mapleIndent{2} yt\,:=\,\mathit{collect} (\mathit{expand} (\mathit{convert} (\mathit{taylor} (y,\,Variable \, = \, 0,\,MaxDegree + 1),\,polynom)),\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} x0\,:=\,\mathit{coeff} (xt,\,Variable,\,0);\\
\mapleIndent{1} y0\,:=\,\mathit{coeff} (yt,\,Variable,\,0);\\
\mapleIndent{1} xt\,:=\,xt-x0;\\
\mapleIndent{1} yt\,:=\,yt-y0;\\
\mapleIndent{1} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable);\\
\mapleIndent{1} shifted\,:=\,\mathit{ldegree} (yt,\,Variable)<MinDegree;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} temp\,:=\,xt;\\
\mapleIndent{2} xt\,:=\,yt;\\
\mapleIndent{2} yt\,:=\,temp;\\
\mapleIndent{2} MinDegree\,:=\,\mathit{ldegree} (xt,\,Variable)\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} a\,:=\,\mathit{array} (1..MaxDegree-MinDegree + 1);\\
\mapleIndent{1} z\,:=\,\mathit{coeff} (xt,\,Variable,\,MinDegree)\hat{~}{-1};\\
\mapleIndent{1} \textbf{if} \,z<0 \, \textbf{and} \, AllowNegation \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,-xt;\\
\mapleIndent{2} z\,:=\,-z;\\
\mapleIndent{2} Negate\,:=\,true\\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} Negate\,:=\,false\\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} arg\,:=\,\mathit{argument} (z);\\
\mapleIndent{1} a[1]\,:=\,\mathit{abs} (z)\hat{~}{MinDegree\hat{~}{-1}} \ast (\mathit{cos} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}) + r1 st I \ast \mathit{sin} (((2 \ast MinDegree + -4 + 2 \ast Branch) \ast Pi + arg) \ast MinDegree\hat{~}{-1}));\\
\mapleIndent{1} p\,:=\,a[1] \ast Variable;\\
\mapleIndent{1} \textbf{for} \,j \,\textbf{from} \,2 \,\textbf{to} \,MaxDegree-MinDegree + 1 \,\textbf{do}\\
\mapleIndent{2} p\,:=\,p + a[j] \ast Variable\hat{~}{j}\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} q\,:=\,\mathit{Composition} (yt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} p\,:=\,\mathit{Composition} (xt,\,p,\,Variable,\,MaxDegree);\\
\mapleIndent{1} i\,:=\,MinDegree + 1;\\
\mapleIndent{1} j\,:=\,2;\\
\mapleIndent{1} \textbf{while} \,i&leMaxDegree \,\textbf{do}\\
\mapleIndent{2} sols\,:=\,[\mathit{solve} (p[i] \, = \, 0,\,a[j])];\\
\mapleIndent{2} q[i]\,:=\,\mathit{expand} (\mathit{subs} (a[j] \, = \, sols[1],\,q[i]));\\
\mapleIndent{2} \textbf{if} \,i<MaxDegree \, \textbf{then} \\
\mapleIndent{3} \textbf{for} \,k \,\textbf{from} \,i + 1 \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{4} p[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,p[k]);\\
\mapleIndent{4} q[k]\,:=\,\mathit{subs} (a[j] \, = \, sols[1],\,q[k])\\
\mapleIndent{3} \textbf{end\ do};\\
\mapleIndent{2} \textbf{end\ if}; ;\\
\mapleIndent{2} a[j]\,:=\,sols[1];\\
\mapleIndent{2} i\,:=\,i + 1;\\
\mapleIndent{2} j\,:=\,j + 1\\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} xt\,:=\,q[0];\\
\mapleIndent{1} \textbf{for} \,i \,\textbf{to} \,MaxDegree \,\textbf{do}\\
\mapleIndent{2} \textbf{if} \,q[i] \, <> \, 0 \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,xt + q[i] \ast Variable\hat{~}{i}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ do};;\\
\mapleIndent{1} \textbf{if} \,shifted \, \textbf{then} \\
\mapleIndent{2} xt\,:=\,x0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} yt\,:=\,y0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} yt\,:=\,y0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{else}\\
\mapleIndent{2} yt\,:=\,y0 + xt;\\
\mapleIndent{2} \textbf{if} \,Negate \, \textbf{then} \\
\mapleIndent{3} xt\,:=\,x0-Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{else}\\
\mapleIndent{3} xt\,:=\,x0 + Variable\hat{~}{MinDegree}\\
\mapleIndent{2} \textbf{end\ if}; \\
\mapleIndent{1} \textbf{end\ if}; ;\\
\mapleIndent{1} \mathit{printf} (``Elapsed\ Time:\ %0.3f\ s.
'',\,\mathit{time} ()-StartTime);\\
\mapleIndent{1} \mathit{RETURN} ([xt,\,yt])\\
\textbf{end\ proc};\]}
\end{center}
\end{maplelatex}
\end{center}
\end{maplelatex}
\begin{Maple Heading 1}{
\begin{Maple Heading 1}{
\textbf{Exempel 1}}\end{Maple Heading 1}

}\end{Maple Heading 1}

\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^3+t^2, t^6+t^5, t, 0, 10, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.015 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[t^2, t^5-(3/2)*t^6+(21/8)*t^7-5*t^8+(1287/128)*t^9-21*t^10]}{\[\displaystyle [{t}^{2},{t}^{5}-3/2\,{t}^{6}+{\frac {21\,{t}^{7}}{8}}-5\,{t}^{8}+{\frac {1287\,{t}^{9}}{128}}-21\,{t}^{10}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^3+t^2, t^6+t^5, t, -1, 10, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.015 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[t, 163438*t^10+29070*t^9+5304*t^8+1001*t^7+198*t^6+42*t^5+10*t^4+3*t^3+3*t^2-t]}{\[\displaystyle [t,163438\,{t}^{10}+29070\,{t}^{9}+5304\,{t}^{8}+1001\,{t}^{7}+198\,{t}^{6}+42\,{t}^{5}+10\,{t}^{4}+3\,{t}^{3}+3\,{t}^{2}\\
\mbox{}-t]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{plot([[t^3+t^2, t^6+t^5, t = -1.1 .. .5], [t^2, t^5-(3/2)*t^6+(21/8)*t^7-5*t^8+(1287/128)*t^9-21*t^10, t = -.45 .. .6], [t, 163438*t^10+29070*t^9+5304*t^8+1001*t^7+198*t^6+42*t^5+10*t^4+3*t^3+3*t^2-t, t = -.1 .. .2]], color = [blue, red, red], linestyle = [dot, solid, solid], thickness = [7, 2, 2], scaling = constrained, size = [.5, .5])}{\[{\it plot} \left( [[{t}^{3}+{t}^{2},{t}^{6}+{t}^{5},t={- 1.1\ldots  0.5\\
\mbox{}}],[{t}^{2},{t}^{5}-3/2\,{t}^{6}+{\frac {21\,{t}^{7}}{8}}-5\,{t}^{8}+{\frac {1287\,{t}^{9}}{128}}\\
\mbox{}-21\,{t}^{10},t={- 0.45\ldots  0.6}\\
\mbox{}],[t,163438\,{t}^{10}+29070\,{t}^{9}+5304\,{t}^{8}+1001\,{t}^{7}+198\,{t}^{6}+42\,{t}^{5}+10\,{t}^{4}+3\,{t}^{3}+3\,{t}^{2}\\
\mbox{}-t,t={- 0.1\ldots  0.2}]],{\it color}\\
\mbox{}=[{\it blue},{\it red},{\it red}],{\it linestyle}=[{\it dot}\\
\mbox{},{\it solid},{\it solid}],{\it thickness}=[7,2,2],{\it scaling}\\
\mbox{}={\it constrained},{\it size}=[ 0.5, 0.5\\
\mbox{}] \right) \]}
\end{mapleinput}
\mapleresult
\mapleplot{kurvorplot2d1.eps}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{}{\[\]}
\end{mapleinput}
\end{maplegroup}
\begin{Maple Heading 1}{
\begin{Maple Heading 1}{
\textbf{Exempel 2}\mapleinline{inert}{2d}{}{$\displaystyle $}
}\end{Maple Heading 1}

}\end{Maple Heading 1}

\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(3*sin(t), 2*cos(t), t, 0, 10, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.016 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[t, 2-(1/9)*t^2-(1/324)*t^4-(1/5832)*t^6-(5/419904)*t^8-(7/7558272)*t^10]}{\[\displaystyle [t,2-1/9\,{t}^{2}-{\frac {{t}^{4}}{324}}-{\frac {{t}^{6}}{5832}}-{\frac {5\,{t}^{8}}{419904}}-{\frac {7\,{t}^{10}}{7558272}}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(3*sin(t), 2*cos(t), t, Pi, 10, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.015 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[t, -2+(1/9)*t^2+(1/324)*t^4+(1/5832)*t^6+(5/419904)*t^8+(7/7558272)*t^10]}{\[\displaystyle [t,-2+1/9\,{t}^{2}+{\frac {{t}^{4}}{324}}+{\frac {{t}^{6}}{5832}}+{\frac {5\,{t}^{8}}{419904}}+{\frac {7\,{t}^{10}}{7558272}}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(3*sin(t), 2*cos(t), t, (1/2)*Pi, 10, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.000 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[3-(3/8)*t^2-(3/128)*t^4-(3/1024)*t^6-(15/32768)*t^8-(21/262144)*t^10, t]}{\[\displaystyle [3-3/8\,{t}^{2}-{\frac {3\,{t}^{4}}{128}}-{\frac {3\,{t}^{6}}{1024}}-{\frac {15\,{t}^{8}}{32768}}-{\frac {21\,{t}^{10}}{262144}},t]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(3*sin(t), 2*cos(t), t, -(1/2)*Pi, 10, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.000 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[-3+(3/8)*t^2+(3/128)*t^4+(3/1024)*t^6+(15/32768)*t^8+(21/262144)*t^10, t]}{\[\displaystyle [-3+3/8\,{t}^{2}+{\frac {3\,{t}^{4}}{128}}+{\frac {3\,{t}^{6}}{1024}}+{\frac {15\,{t}^{8}}{32768}}+{\frac {21\,{t}^{10}}{262144}},t]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{plot([[3*sin(t), 2*cos(t), t = -Pi .. Pi], [t, 2-(1/9)*t^2-(1/324)*t^4-(1/5832)*t^6-(5/419904)*t^8-(7/7558272)*t^10, t = -3.5 .. 3.5], [t, -2+(1/9)*t^2+(1/324)*t^4+(1/5832)*t^6+(5/419904)*t^8+(7/7558272)*t^10, t = -3.5 .. 3.5], [3-(3/8)*t^2-(3/128)*t^4-(3/1024)*t^6-(15/32768)*t^8-(21/262144)*t^10, t, t = -2.3 .. 2.3], [-3+(3/8)*t^2+(3/128)*t^4+(3/1024)*t^6+(15/32768)*t^8+(21/262144)*t^10, t, t = -2.3 .. 2.3]], color = [blue, red, red, red, red], linestyle = [dot, solid, solid, solid, solid], thickness = [7, 2, 2, 2, 2], scaling = constrained, size = [.5, .5])}{\[{\it plot} \left( [[3\,\sin \left( t \right) ,2\,\cos \left( t \right) ,t={-\pi \ldots \pi }\\
\mbox{}],[t,2-1/9\,{t}^{2}-{\frac {{t}^{4}}{324}}-{\frac {{t}^{6}}{5832}}-{\frac {5\,{t}^{8}}{419904}}-{\frac {7\,{t}^{10}}{7558272}},t={- 3.5\\
\mbox{}\ldots  3.5}\\
\mbox{}],[t,-2+1/9\,{t}^{2}+{\frac {{t}^{4}}{324}}+{\frac {{t}^{6}}{5832}}+{\frac {5\,{t}^{8}}{419904}}+{\frac {7\,{t}^{10}}{7558272}},t={- 3.5\\
\mbox{}\ldots  3.5}\\
\mbox{}],[3-3/8\,{t}^{2}-{\frac {3\,{t}^{4}}{128}}-{\frac {3\,{t}^{6}}{1024}}-{\frac {15\,{t}^{8}}{32768}}-{\frac {21\,{t}^{10}}{262144}},t,t={- 2.3\\
\mbox{}\ldots  2.3}\\
\mbox{}],[-3+3/8\,{t}^{2}+{\frac {3\,{t}^{4}}{128}}+{\frac {3\,{t}^{6}}{1024}}+{\frac {15\,{t}^{8}}{32768}}+{\frac {21\,{t}^{10}}{262144}},t,t={- 2.3\\
\mbox{}\ldots  2.3}\\
\mbox{}]],{\it color}=[{\it blue},{\it red},{\it red},{\it red},{\it red}],{\it linestyle}\\
\mbox{}=[{\it dot},{\it solid},{\it solid},{\it solid},{\it solid}],{\it thickness}=[7,2\\
\mbox{},2,2,2],{\it scaling}={\it constrained},{\it size}\\
\mbox{}=[ 0.5, 0.5] \right) \]}
\end{mapleinput}
\mapleresult
\mapleplot{kurvorplot2d2.eps}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{}{\[\]}
\end{mapleinput}
\end{maplegroup}
\begin{Maple Heading 1}{
\begin{Maple Heading 1}{
\textbf{Exempel 3}}\end{Maple Heading 1}

}\end{Maple Heading 1}

\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^3*(t-1)^3*(t+1)^3, t^5*(t-1)^2*(t+1)^2, t, 0, 15, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.016 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[t^3, -1428*t^15-273*t^13-55*t^11-12*t^9-3*t^7-t^5]}{\[\displaystyle [{t}^{3},-1428\,{t}^{15}-273\,{t}^{13}-55\,{t}^{11}-12\,{t}^{9}-3\,{t}^{7}-{t}^{5}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^3*(t-1)^3*(t+1)^3, t^5*(t-1)^2*(t+1)^2, t, 1, 15, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.031 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[(1/2)*sqrt(4)*t^3-(9/4)*t^4+(207/64)*sqrt(4)*t^5-21*t^6+(150183/4096)*sqrt(4)*t^7-(137655/512)*t^8+(66893079/131072)*sqrt(4)*t^9-3978*t^10+(132735945771/16777216)*sqrt(4)*t^11-(8385901667/131072)*t^12+(70379121262905/536870912)*sqrt(4)*t^13-(4345965/4)*t^14+(78087826643607459/34359738368)*sqrt(4)*t^15, t^2]}{\[\displaystyle [1/2\, \sqrt{4}{t}^{3}-9/4\,{t}^{4}+{\frac {207\, \sqrt{4}{t}^{5}}{64}}-21\,{t}^{6}+{\frac {150183\, \sqrt{4}{t}^{7}}{4096}}\\
\mbox{}-{\frac {137655\,{t}^{8}}{512}}+{\frac {66893079\, \sqrt{4}{t}^{9}}{131072}}-3978\,{t}^{10}+{\frac {132735945771\, \sqrt{4}{t}^{11}}{16777216}}\\
\mbox{}-{\frac {8385901667\,{t}^{12}}{131072}}+{\frac {70379121262905\, \sqrt{4}{t}^{13}}{536870912}}\\
\mbox{}-{\frac {4345965\,{t}^{14}}{4}}+{\frac {78087826643607459\, \sqrt{4}{t}^{15}}{34359738368}},{t}^{2\\
\mbox{}}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^3*(t-1)^3*(t+1)^3, t^5*(t-1)^2*(t+1)^2, t, -1, 15, 0, true); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.047 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[(1/2)*sqrt(4)*t^3+(9/4)*t^4+(207/64)*sqrt(4)*t^5+21*t^6+(150183/4096)*sqrt(4)*t^7+(137655/512)*t^8+(66893079/131072)*sqrt(4)*t^9+3978*t^10+(132735945771/16777216)*sqrt(4)*t^11+(8385901667/131072)*t^12+(70379121262905/536870912)*sqrt(4)*t^13+(4345965/4)*t^14+(78087826643607459/34359738368)*sqrt(4)*t^15, -t^2]}{\[\displaystyle [1/2\, \sqrt{4}{t}^{3}+9/4\,{t}^{4}+{\frac {207\, \sqrt{4}{t}^{5}}{64}}+21\,{t}^{6}+{\frac {150183\, \sqrt{4}{t}^{7}}{4096}}\\
\mbox{}+{\frac {137655\,{t}^{8}}{512}}+{\frac {66893079\, \sqrt{4}{t}^{9}}{131072}}+3978\,{t}^{10}+{\frac {132735945771\, \sqrt{4}{t}^{11}}{16777216}}\\
\mbox{}+{\frac {8385901667\,{t}^{12}}{131072}}+{\frac {70379121262905\, \sqrt{4}{t}^{13}}{536870912}}\\
\mbox{}+{\frac {4345965\,{t}^{14}}{4}}+{\frac {78087826643607459\, \sqrt{4}{t}^{15}}{34359738368}},-{t}^{2\\
\mbox{}}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{plot([[t^3*(t-1)^3*(t+1)^3, t^5*(t-1)^2*(t+1)^2, t = -1.1 .. 1.1], [t^3, -1428*t^15-273*t^13-55*t^11-12*t^9-3*t^7-t^5, t = -.4 .. .4], [(1/2)*sqrt(4)*t^3-(9/4)*t^4+(207/64)*sqrt(4)*t^5-21*t^6+(150183/4096)*sqrt(4)*t^7-(137655/512)*t^8+(66893079/131072)*sqrt(4)*t^9-3978*t^10+(132735945771/16777216)*sqrt(4)*t^11-(8385901667/131072)*t^12+(70379121262905/536870912)*sqrt(4)*t^13-(4345965/4)*t^14+(78087826643607459/34359738368)*sqrt(4)*t^15, t^2, t = -.26 .. .26], [(1/2)*sqrt(4)*t^3+(9/4)*t^4+(207/64)*sqrt(4)*t^5+21*t^6+(150183/4096)*sqrt(4)*t^7+(137655/512)*t^8+(66893079/131072)*sqrt(4)*t^9+3978*t^10+(132735945771/16777216)*sqrt(4)*t^11+(8385901667/131072)*t^12+(70379121262905/536870912)*sqrt(4)*t^13+(4345965/4)*t^14+(78087826643607459/34359738368)*sqrt(4)*t^15, -t^2, t = -.26 .. .26]], color = [blue, red, red, red], linestyle = [dot, solid, solid, solid], thickness = [7, 2, 2, 2], scaling = constrained, size = [.5, .5])}{\[{\it plot} \left( [[{t}^{3} \left( t-1 \right) ^{3} \left( t+1 \right) ^{3},{t}^{5} \left( t-1 \right) ^{2} \left( t+1 \right) ^{2}\\
\mbox{},t={- 1.1\ldots  1.1}],[{t}^{3},-1428\,{t}^{15}\\
\mbox{}-273\,{t}^{13}-55\,{t}^{11}-12\,{t}^{9}-3\,{t}^{7}-{t}^{5},t={- 0.4\ldots  0.4}\\
\mbox{}],[1/2\, \sqrt{4}{t}^{3}-9/4\,{t}^{4}+{\frac {207\, \sqrt{4}{t}^{5}}{64}}-21\,{t}^{6}+{\frac {150183\, \sqrt{4}{t}^{7}}{4096}}\\
\mbox{}-{\frac {137655\,{t}^{8}}{512}}+{\frac {66893079\, \sqrt{4}{t}^{9}}{131072}}-3978\,{t}^{10}+{\frac {132735945771\, \sqrt{4}{t}^{11}}{16777216}}\\
\mbox{}-{\frac {8385901667\,{t}^{12}}{131072}}+{\frac {70379121262905\, \sqrt{4}{t}^{13}}{536870912}}\\
\mbox{}-{\frac {4345965\,{t}^{14}}{4}}+{\frac {78087826643607459\, \sqrt{4}{t}^{15}}{34359738368}},{t}^{2\\
\mbox{}},t={- 0.26\ldots  0.26}\\
\mbox{}],[1/2\, \sqrt{4}{t}^{3}+9/4\,{t}^{4}+{\frac {207\, \sqrt{4}{t}^{5}}{64}}+21\,{t}^{6}+{\frac {150183\, \sqrt{4}{t}^{7}}{4096}}\\
\mbox{}+{\frac {137655\,{t}^{8}}{512}}+{\frac {66893079\, \sqrt{4}{t}^{9}}{131072}}+3978\,{t}^{10}+{\frac {132735945771\, \sqrt{4}{t}^{11}}{16777216}}\\
\mbox{}+{\frac {8385901667\,{t}^{12}}{131072}}+{\frac {70379121262905\, \sqrt{4}{t}^{13}}{536870912}}\\
\mbox{}+{\frac {4345965\,{t}^{14}}{4}}+{\frac {78087826643607459\, \sqrt{4}{t}^{15}}{34359738368}},-{t}^{2\\
\mbox{}},t={- 0.26\ldots  0.26}\\
\mbox{}]],{\it color}=[{\it blue},{\it red},{\it red},{\it red}],{\it linestyle}\\
\mbox{}=[{\it dot},{\it solid},{\it solid},{\it solid}],{\it thickness}=[7,2,2\\
\mbox{},2],{\it scaling}={\it constrained},{\it size}=[ 0.5\\
\mbox{}, 0.5] \right) \]}
\end{mapleinput}
\mapleresult
\mapleplot{kurvorplot2d3.eps}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{}{\[\]}
\end{mapleinput}
\end{maplegroup}
\begin{Maple Heading 1}{
\begin{Maple Heading 1}{
\textbf{Exempel 4}}\end{Maple Heading 1}

}\end{Maple Heading 1}

\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^3-t^2, t^3+t^2, t, 0, 10, 0, true); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.000 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[-t^2, 3*t^4+2*t^3+t^2+(21/4)*t^5+10*t^6+(1287/64)*t^7+42*t^8+(46189/512)*t^9+198*t^10]}{\[\displaystyle [-{t}^{2},3\,{t}^{4}+2\,{t}^{3}+{t}^{2}+{\frac {21\,{t}^{5}}{4}}+10\,{t}^{6}+{\frac {1287\,{t}^{7}}{64}}+42\,{t}^{8}+{\frac {46189\,{t}^{9}}{512}}+198\,{t}^{10}\\
\mbox{}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^3-t^2, t^3+t^2, t, 0, 10, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.015 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[t^2, -t^2-(2*I)*t^3+3*t^4+(21/4*I)*t^5-10*t^6-(1287/64*I)*t^7+42*t^8+(46189/512*I)*t^9-198*t^10]}{\[\displaystyle [{t}^{2},-{t}^{2}-2\,i{t}^{3}+3\,{t}^{4}+{\frac {21\,i}{4}}{t}^{5}\\
\mbox{}-10\,{t}^{6}-{\frac {1287\,i}{64}}{t}^{7}+42\,{t}^{8}+{\frac {46189\,i}{512}}{t}^{9}-198\,{t}^{10}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{plot([[t^3-t^2, t^3+t^2, t = -1 .. 1], [-t^2, 3*t^4+2*t^3+t^2+(21/4)*t^5+10*t^6+(1287/64)*t^7+42*t^8+(46189/512)*t^9+198*t^10, t = -.65 .. .5], [t^2, Re(-t^2-(2*I)*t^3+3*t^4+(21/4*I)*t^5-10*t^6-(1287/64*I)*t^7+42*t^8+(46189/512*I)*t^9-198*t^10), t = -.5 .. .5], [t^2, Im(-t^2-(2*I)*t^3+3*t^4+(21/4*I)*t^5-10*t^6-(1287/64*I)*t^7+42*t^8+(46189/512*I)*t^9-198*t^10), t = -.6 .. .6]], color = [blue, red, purple, purple], linestyle = [dot, solid, dashdot, dashdot], thickness = [7, 2, 2, 2], scaling = constrained, size = [.5, .5])}{\[{\it plot} \left( [[{t}^{3}-{t}^{2},{t}^{3}+{t}^{2},t={-1\ldots 1}],[-{t}^{2\\
\mbox{}},3\,{t}^{4}+2\,{t}^{3}+{t}^{2}+{\frac {21\,{t}^{5}}{4}}+10\,{t}^{6}+{\frac {1287\,{t}^{7}}{64}}+42\,{t}^{8}+{\frac {46189\,{t}^{9}}{512}}+198\,{t}^{10},t={- 0.65\\
\mbox{}\ldots  0.5}\\
\mbox{}],[{t}^{2},\Re \left( -{t}^{2}-2\,i{t}^{3}+3\,{t}^{4}+{\frac {21\,i}{4}}{t}^{5}\\
\mbox{}-10\,{t}^{6}-{\frac {1287\,i}{64}}{t}^{7}+42\,{t}^{8}+{\frac {46189\,i}{512}}{t}^{9}-198\,{t}^{10} \right) ,t={- 0.5\ldots  0.5}\\
\mbox{}],[{t}^{2},\Im \left( -{t}^{2}-2\,i{t}^{3}+3\,{t}^{4}+{\frac {21\,i}{4}}{t}^{5}\\
\mbox{}-10\,{t}^{6}-{\frac {1287\,i}{64}}{t}^{7}+42\,{t}^{8}+{\frac {46189\,i}{512}}{t}^{9}-198\,{t}^{10} \right) ,t={- 0.6\ldots  0.6}\\
\mbox{}]],{\it color}=[{\it blue},{\it red},{\it purple},{\it purple}]\\
\mbox{},{\it linestyle}=[{\it dot},{\it solid},{\it dashdot}\\
\mbox{},{\it dashdot}\\
\mbox{}],{\it thickness}=[7,2,2,2],{\it scaling}={\it constrained}\\
\mbox{},{\it size}=[ 0.5, 0.5] \right) \]}
\end{mapleinput}
\mapleresult
\mapleplot{kurvorplot2d4.eps}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{}{\[\]}
\end{mapleinput}
\end{maplegroup}
\begin{Maple Heading 1}{
\begin{Maple Heading 1}{
\textbf{Exempel 5}}\end{Maple Heading 1}

}\end{Maple Heading 1}

\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^4-t^3, t^4+t^3, t, 0, 10, 2, true); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.016 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[-t^3, 2*t^4+t^3+(8/3)*t^5+4*t^6+(520/81)*t^7+(2618/243)*t^8+(56/3)*t^9+(217360/6561)*t^10]}{\[\displaystyle [-{t}^{3},2\,{t}^{4}+{t}^{3}+8/3\,{t}^{5}+4\,{t}^{6}+{\frac {520\,{t}^{7}}{81}}+{\frac {2618\,{t}^{8}}{243}}+{\frac {56\,{t}^{9}}{3}}+{\frac {217360\,{t}^{10}}{6561}}\\
\mbox{}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{Reparametrize(t^4-t^3, t^4+t^3, t, 0, 10, 0, false); 1}{\[\]}
\end{mapleinput}
\mapleresult
Elapsed Time: 0.016 s.
\mapleresult
\begin{maplelatex}
\mapleinline{inert}{2d}{[t^3, 2*t^4-t^3-(8/3)*t^5+4*t^6-(520/81)*t^7+(2618/243)*t^8-(56/3)*t^9+(217360/6561)*t^10]}{\[\displaystyle [{t}^{3},2\,{t}^{4}-{t}^{3}-8/3\,{t}^{5}+4\,{t}^{6}-{\frac {520\,{t}^{7}}{81}}+{\frac {2618\,{t}^{8}}{243}}-{\frac {56\,{t}^{9}}{3}}+{\frac {217360\,{t}^{10}}{6561}}\\
\mbox{}]\]}
\end{maplelatex}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{plot([[t^4-t^3, t^4+t^3, t = -1 .. 1], [t^3, 2*t^4-t^3-(8/3)*t^5+4*t^6-(520/81)*t^7+(2618/243)*t^8-(56/3)*t^9+(217360/6561)*t^10, t = -.6 .. .75]], color = [blue, red], linestyle = [dot, solid], thickness = [7, 2], scaling = constrained, size = [.5, .5])}{\[{\it plot} \left( [[{t}^{4}-{t}^{3},{t}^{4}+{t}^{3},t={-1\ldots 1}],[{t}^{3},2\,{t}^{4}\\
\mbox{}-{t}^{3}-8/3\,{t}^{5}+4\,{t}^{6}-{\frac {520\,{t}^{7}}{81}}+{\frac {2618\,{t}^{8}}{243}}-{\frac {56\,{t}^{9}}{3}}+{\frac {217360\,{t}^{10}}{6561}},t={- 0.6\\
\mbox{}\ldots  0.75}\\
\mbox{}]],{\it color}=[{\it blue},{\it red}],{\it linestyle}\\
\mbox{}=[{\it dot},{\it solid}],{\it thickness}=[7,2],{\it scaling}\\
\mbox{}={\it constrained},{\it size}=[ 0.5, 0.5\\
\mbox{}] \right) \]}
\end{mapleinput}
\mapleresult
\mapleplot{kurvorplot2d5.eps}
\end{maplegroup}
\begin{maplegroup}
\begin{mapleinput}
\mapleinline{active}{2d}{}{\[\]}
\end{mapleinput}
\end{maplegroup}
\begin{Maple Normal}{
\begin{Maple Normal}{
\mapleinline{inert}{2d}{}{\[\displaystyle \]}
}\end{Maple Normal}
}\end{Maple Normal}
\end{document}
